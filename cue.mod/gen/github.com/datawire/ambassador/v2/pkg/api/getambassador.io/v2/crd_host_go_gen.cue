// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/datawire/ambassador/v2/pkg/api/getambassador.io/v2

package v2

import (
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

#ACMEProviderSpec: {
	// Specifies who to talk ACME with to get certs. Defaults to Let's
	// Encrypt; if "none" (case-insensitive), do not try to do ACME for
	// this Host.
	authority?: string @go(Authority)
	email?:     string @go(Email)

	// Specifies the Kubernetes Secret to use to store the private key of the ACME
	// account (essentially, where to store the auto-generated password for the
	// auto-created ACME account).  You should not normally need to set this--the
	// default value is based on a combination of the ACME authority being registered
	// wit and the email address associated with the account.
	//
	// Note that this is a native-Kubernetes-style core.v1.LocalObjectReference, not
	// an Ambassador-style `{name}.{namespace}` string.  Because we're opinionated, it
	// does not support referencing a Secret in another namespace (because most native
	// Kubernetes resources don't support that), but if we ever abandon that opinion
	// and decide to support non-local references it, it would be by adding a
	// `namespace:` field by changing it from a core.v1.LocalObjectReference to a
	// core.v1.SecretReference, not by adopting the `{name}.{namespace}` notation.
	privateKeySecret?: null | corev1.#LocalObjectReference @go(PrivateKeySecret,*corev1.LocalObjectReference)

	// This is normally set automatically
	registration?: string @go(Registration)
}

#InsecureRequestPolicy: {
	// +kubebuilder:validation:Enum={"Redirect","Reject","Route"}
	action?:         string     @go(Action)
	additionalPort?: null | int @go(AdditionalPort,*int)
}

#RequestPolicy: {
	insecure?: #InsecureRequestPolicy @go(Insecure)
}

#PreviewURLSpec: {
	// Is the Preview URL feature enabled?
	enabled?: null | bool @go(Enabled,*bool)

	// What type of Preview URL is allowed?
	type?: #PreviewURLType @go(Type)
}

// What type of Preview URL is allowed?
//
//  - path
//  - wildcard
//  - datawire // FIXME rename this before release
//
// +kubebuilder:validation:Enum={"Path"}
#PreviewURLType: string

// HostSpec defines the desired state of Host
#HostSpec: {
	// Common to all Ambassador objects (and optional).
	ambassador_id?: #AmbassadorID @go(AmbassadorID)

	// A compatibility alias for "ambassador_id"; because Host
	// used to be specified with protobuf, and jsonpb allowed
	// either "ambassador_id" or "ambassadorId", and even though
	// we didn't tell people about "ambassadorId" it's what the
	// web policy console generated because of jsonpb.  So Hosts
	// with 'ambassadorId' exist in the wild.
	ambassadorId?: #AmbassadorID @go(DeprecatedAmbassadorID)

	// Hostname by which the Ambassador can be reached.
	hostname?: string @go(Hostname)

	// Selector by which we can find further configuration. Defaults to hostname=$hostname
	//
	// +k8s:conversion-gen:rename=MappingSelector
	selector?: null | metav1.#LabelSelector @go(Selector,*metav1.LabelSelector)

	// Specifies whether/who to talk ACME with to automatically manage the $tlsSecret.
	acmeProvider?: null | #ACMEProviderSpec @go(AcmeProvider,*ACMEProviderSpec)

	// Name of the Kubernetes secret into which to save generated
	// certificates.  If ACME is enabled (see $acmeProvider), then the
	// default is $hostname; otherwise the default is "".  If the value
	// is "", then we do not do TLS for this Host.
	//
	// Note that this is a native-Kubernetes-style core.v1.LocalObjectReference, not
	// an Ambassador-style `{name}.{namespace}` string.  Because we're opinionated, it
	// does not support referencing a Secret in another namespace (because most native
	// Kubernetes resources don't support that), but if we ever abandon that opinion
	// and decide to support non-local references it, it would be by adding a
	// `namespace:` field by changing it from a core.v1.LocalObjectReference to a
	// core.v1.SecretReference, not by adopting the `{name}.{namespace}` notation.
	tlsSecret?: null | corev1.#LocalObjectReference @go(TLSSecret,*corev1.LocalObjectReference)

	// Request policy definition.
	requestPolicy?: null | #RequestPolicy @go(RequestPolicy,*RequestPolicy)

	// Configuration for the Preview URL feature of Service Preview. Defaults to preview URLs not enabled.
	previewUrl?: null | #PreviewURLSpec @go(PreviewUrl,*PreviewURLSpec)

	// Name of the TLSContext the Host resource is linked with.
	// It is not valid to specify both `tlsContext` and `tls`.
	//
	// Note that this is a native-Kubernetes-style core.v1.LocalObjectReference, not
	// an Ambassador-style `{name}.{namespace}` string.  Because we're opinionated, it
	// does not support referencing a Secret in another namespace (because most native
	// Kubernetes resources don't support that), but if we ever abandon that opinion
	// and decide to support non-local references it, it would be by adding a
	// `namespace:` field by changing it from a core.v1.LocalObjectReference to a
	// core.v1.SecretReference, not by adopting the `{name}.{namespace}` notation.
	tlsContext?: null | corev1.#LocalObjectReference @go(TLSContext,*corev1.LocalObjectReference)

	// TLS configuration.  It is not valid to specify both
	// `tlsContext` and `tls`.
	tls?: null | #TLSConfig @go(TLS,*TLSConfig)
}

#TLSConfig: {
	cert_chain_file?:   string      @go(CertChainFile)
	private_key_file?:  string      @go(PrivateKeyFile)
	ca_secret?:         string      @go(CASecret)
	cacert_chain_file?: string      @go(CAcertChainFile)
	alpn_protocols?:    string      @go(AlpnProtocols)
	cert_required?:     null | bool @go(CertRequired,*bool)
	min_tls_version?:   string      @go(MinTLSVersion)
	max_tls_version?:   string      @go(MaxTLSVersion)
	cipher_suites?: [...string] @go(CipherSuites,[]string)
	ecdh_curves?: [...string] @go(ECDHCurves,[]string)
	redirect_cleartext_from?: null | int @go(RedirectCleartextFrom,*int)
	sni?:                     string     @go(SNI)
}

// The first value listed in the Enum marker becomes the "zero" value,
// and it would be great if "Pending" could be the default value; but
// it's Important that the "zero" value be able to be shown as
// empty/omitted from display, and we really do want `kubectl get
// hosts` to say "Pending" in the "STATE" column, and not leave the
// column empty.
//
// +kubebuilder:validation:Type=string
// +kubebuilder:validation:Enum={"Initial","Pending","Ready","Error"}
#HostState: _ // #enumHostState

#enumHostState:
	#HostState_Initial |
	#HostState_Pending |
	#HostState_Ready |
	#HostState_Error

#values_HostState: {
	HostState_Initial: #HostState_Initial
	HostState_Pending: #HostState_Pending
	HostState_Ready:   #HostState_Ready
	HostState_Error:   #HostState_Error
}

// +kubebuilder:validation:Type=string
// +kubebuilder:validation:Enum={"NA","DefaultsFilled","ACMEUserPrivateKeyCreated","ACMEUserRegistered","ACMECertificateChallenge"}
#HostPhase: _ // #enumHostPhase

#enumHostPhase:
	#HostPhase_NA |
	#HostPhase_DefaultsFilled |
	#HostPhase_ACMEUserPrivateKeyCreated |
	#HostPhase_ACMEUserRegistered |
	#HostPhase_ACMECertificateChallenge

#values_HostPhase: {
	HostPhase_NA:                        #HostPhase_NA
	HostPhase_DefaultsFilled:            #HostPhase_DefaultsFilled
	HostPhase_ACMEUserPrivateKeyCreated: #HostPhase_ACMEUserPrivateKeyCreated
	HostPhase_ACMEUserRegistered:        #HostPhase_ACMEUserRegistered
	HostPhase_ACMECertificateChallenge:  #HostPhase_ACMECertificateChallenge
}

// HostStatus defines the observed state of Host
#HostStatus: {
	tlsCertificateSource?: #HostTLSCertificateSource @go(TLSCertificateSource)
	state?:                #HostState                @go(State)

	// phaseCompleted and phasePending are valid when state==Pending or
	// state==Error.
	phaseCompleted?: #HostPhase @go(PhaseCompleted)

	// phaseCompleted and phasePending are valid when state==Pending or
	// state==Error.
	phasePending?: #HostPhase @go(PhasePending)

	// errorReason, errorTimestamp, and errorBackoff are valid when state==Error.
	errorReason?:    string                  @go(ErrorReason)
	errorTimestamp?: null | metav1.#Time     @go(ErrorTimestamp,*metav1.Time)
	errorBackoff?:   null | metav1.#Duration @go(ErrorBackoff,*metav1.Duration)
}

// +kubebuilder:validation:Enum={"Unknown","None","Other","ACME"}
#HostTLSCertificateSource: string

// Host is the Schema for the hosts API
//
// +kubebuilder:object:root=true
// +kubebuilder:storageversion
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Hostname",type=string,JSONPath=`.spec.hostname`
// +kubebuilder:printcolumn:name="State",type=string,JSONPath=`.status.state`
// +kubebuilder:printcolumn:name="Phase Completed",type=string,JSONPath=`.status.phaseCompleted`
// +kubebuilder:printcolumn:name="Phase Pending",type=string,JSONPath=`.status.phasePending`
// +kubebuilder:printcolumn:name="Age",type=date,JSONPath=`.metadata.creationTimestamp`
#Host: {
	TypeMeta:  metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta @go(ObjectMeta)
	spec?:     null | #HostSpec   @go(Spec,*HostSpec)
	status?:   #HostStatus        @go(Status)
}

// HostList contains a list of Hosts.
//
// +kubebuilder:object:root=true
#HostList: {
	TypeMeta:  metav1.#TypeMeta
	metadata?: metav1.#ListMeta @go(ListMeta)
	items: [...#Host] @go(Items,[]Host)
}
