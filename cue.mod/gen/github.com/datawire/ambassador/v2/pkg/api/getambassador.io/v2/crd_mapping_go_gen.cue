// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/datawire/ambassador/v2/pkg/api/getambassador.io/v2

package v2

import metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

// MappingSpec defines the desired state of Mapping
#MappingSpec: {
	ambassador_id?: #AmbassadorID @go(AmbassadorID)

	// +kubebuilder:validation:Required
	prefix?:       string      @go(Prefix)
	prefix_regex?: null | bool @go(PrefixRegex,*bool)
	prefix_exact?: null | bool @go(PrefixExact,*bool)

	// +kubebuilder:validation:Required
	service?: string @go(Service)
	add_request_headers?: {[string]: #AddedHeader} @go(AddRequestHeaders,map[string]AddedHeader)
	add_response_headers?: {[string]: #AddedHeader} @go(AddResponseHeaders,map[string]AddedHeader)
	add_linkerd_headers?: null | bool      @go(AddLinkerdHeaders,*bool)
	auto_host_rewrite?:   null | bool      @go(AutoHostRewrite,*bool)
	case_sensitive?:      null | bool      @go(CaseSensitive,*bool)
	docs?:                null | #DocsInfo @go(Docs,*DocsInfo)
	dns_type?:            string           @go(DNSType)
	enable_ipv4?:         null | bool      @go(EnableIPv4,*bool)
	enable_ipv6?:         null | bool      @go(EnableIPv6,*bool)
	circuit_breakers?: [...null | #CircuitBreaker] @go(CircuitBreakers,[]*CircuitBreaker)
	keepalive?:         null | #KeepAlive   @go(KeepAlive,*KeepAlive)
	cors?:              null | #CORS        @go(CORS,*CORS)
	retry_policy?:      null | #RetryPolicy @go(RetryPolicy,*RetryPolicy)
	respect_dns_ttl?:   null | bool         @go(RespectDNSTTL,*bool)
	grpc?:              null | bool         @go(GRPC,*bool)
	host_redirect?:     null | bool         @go(HostRedirect,*bool)
	host_rewrite?:      string              @go(HostRewrite)
	method?:            string              @go(Method)
	method_regex?:      null | bool         @go(MethodRegex,*bool)
	outlier_detection?: string              @go(OutlierDetection)

	// Path replacement to use when generating an HTTP redirect. Used with `host_redirect`.
	path_redirect?: string @go(PathRedirect)

	// Prefix rewrite to use when generating an HTTP redirect. Used with `host_redirect`.
	prefix_redirect?: string @go(PrefixRedirect)

	// Prefix regex rewrite to use when generating an HTTP redirect. Used with `host_redirect`.
	regex_redirect?: null | #RegexMap @go(RegexRedirect,*RegexMap)

	// The response code to use when generating an HTTP redirect. Defaults to 301. Used with
	// `host_redirect`.
	// +kubebuilder:validation:Enum={301,302,303,307,308}
	redirect_response_code?:             null | int                  @go(RedirectResponseCode,*int)
	priority?:                           string                      @go(Priority)
	precedence?:                         null | int                  @go(Precedence,*int)
	cluster_tag?:                        string                      @go(ClusterTag)
	remove_request_headers?:             #StringOrStringList         @go(RemoveRequestHeaders)
	remove_response_headers?:            #StringOrStringList         @go(RemoveResponseHeaders)
	resolver?:                           string                      @go(Resolver)
	rewrite?:                            null | string               @go(Rewrite,*string)
	regex_rewrite?:                      null | #RegexMap            @go(RegexRewrite,*RegexMap)
	shadow?:                             null | bool                 @go(Shadow,*bool)
	connect_timeout_ms?:                 null | #MillisecondDuration @go(ConnectTimeout,*MillisecondDuration)
	cluster_idle_timeout_ms?:            null | #MillisecondDuration @go(ClusterIdleTimeout,*MillisecondDuration)
	cluster_max_connection_lifetime_ms?: null | #MillisecondDuration @go(ClusterMaxConnectionLifetime,*MillisecondDuration)

	// The timeout for requests that use this Mapping. Overrides `cluster_request_timeout_ms` set on the Ambassador Module, if it exists.
	timeout_ms?:      null | #MillisecondDuration @go(Timeout,*MillisecondDuration)
	idle_timeout_ms?: null | #MillisecondDuration @go(IdleTimeout,*MillisecondDuration)
	tls?:             null | #BoolOrString        @go(TLS,*BoolOrString)

	// use_websocket is deprecated, and is equivlaent to setting
	// `allow_upgrade: ["websocket"]`
	use_websocket?: null | bool @go(DeprecatedUseWebsocket,*bool)

	// A case-insensitive list of the non-HTTP protocols to allow
	// "upgrading" to from HTTP via the "Connection: upgrade"
	// mechanism[1].  After the upgrade, Ambassador does not
	// interpret the traffic, and behaves similarly to how it does
	// for TCPMappings.
	//
	// [1]: https://tools.ietf.org/html/rfc7230#section-6.7
	//
	// For example, if your upstream service supports WebSockets,
	// you would write
	//
	//    allow_upgrade:
	//    - websocket
	//
	// Or if your upstream service supports upgrading from HTTP to
	// SPDY (as the Kubernetes apiserver does for `kubectl exec`
	// functionality), you would write
	//
	//    allow_upgrade:
	//    - spdy/3.1
	allow_upgrade?: [...string] @go(AllowUpgrade,[]string)
	weight?:      null | int  @go(Weight,*int)
	bypass_auth?: null | bool @go(BypassAuth,*bool)
	auth_context_extensions?: {[string]: string} @go(AuthContextExtensions,map[string]string)

	// If true, bypasses any `error_response_overrides` set on the Ambassador module.
	bypass_error_response_overrides?: null | bool @go(BypassErrorResponseOverrides,*bool)

	// Error response overrides for this Mapping. Replaces all of the `error_response_overrides`
	// set on the Ambassador module, if any.
	// +kubebuilder:validation:MinItems=1
	error_response_overrides?: [...#ErrorResponseOverride] @go(ErrorResponseOverrides,[]ErrorResponseOverride)
	modules?: [...#UntypedDict] @go(Modules,[]UntypedDict)

	// +k8s:conversion-gen:rename=Hostname
	host?: string @go(Host)

	// +k8s:conversion-gen:rename=DeprecatedHostRegex
	host_regex?: null | bool @go(HostRegex,*bool)

	// +k8s:conversion-gen=false
	headers?: {[string]: #BoolOrString} @go(Headers,map[string]BoolOrString)
	regex_headers?: {[string]: string} @go(RegexHeaders,map[string]string)
	labels?:         #DomainMap           @go(Labels)
	envoy_override?: null | #UntypedDict  @go(EnvoyOverride,*UntypedDict)
	load_balancer?:  null | #LoadBalancer @go(LoadBalancer,*LoadBalancer)

	// +k8s:conversion-gen=false
	query_parameters?: {[string]: #BoolOrString} @go(QueryParameters,map[string]BoolOrString)
	regex_query_parameters?: {[string]: string} @go(RegexQueryParameters,map[string]string)

	// +k8s:conversion-gen:rename=StatsName
	v3StatsName?: string @go(V3StatsName)
}

#RegexMap: {
	pattern?:      string @go(Pattern)
	substitution?: string @go(Substitution)
}

// DocsInfo provides some extra information about the docs for the Mapping
// (used by the Dev Portal)
#DocsInfo: {
	path?:         string                      @go(Path)
	url?:          string                      @go(URL)
	ignored?:      null | bool                 @go(Ignored,*bool)
	display_name?: string                      @go(DisplayName)
	timeout_ms?:   null | #MillisecondDuration @go(Timeout,*MillisecondDuration)
}

// A DomainMap is the overall Mapping.spec.Labels type. It maps domains (kind of
// like namespaces for Mapping labels) to arrays of label groups.
#DomainMap: {[string]: #MappingLabelGroupsArray}

// A MappingLabelGroupsArray is an array of MappingLabelGroups. I know, complex.
#MappingLabelGroupsArray: [...#MappingLabelGroup]

// A MappingLabelGroup is a single element of a MappingLabelGroupsArray: a second
// map, where the key is a human-readable name that identifies the group.
//
// +kubebuilder:validation:MinProperties=1
// +kubebuilder:validation:MaxProperties=1
#MappingLabelGroup: {[string]: #MappingLabelsArray}

// A MappingLabelsArray is the value in the MappingLabelGroup: an array of label
// specifiers.
#MappingLabelsArray: [...#MappingLabelSpecifier]

// A MappingLabelSpecifier (finally!) defines a single label. There are multiple
// kinds of label, so this is more complex than we'd like it to be. See the remarks
// about schema on custom types in `./common.go`.
//
// +kubebuilder:validation:Type="d6e-union:string,object"
#MappingLabelSpecifier: _

// A MappingLabelSpecHeaderStruct is the value struct for MappingLabelSpecifier.Header:
// the form of MappingLabelSpecifier to use when you want to take the label value from
// an HTTP header. (If we make this an anonymous struct like the others, it breaks the
// generation of its deepcopy routine. Sigh.)
#MappingLabelSpecHeaderStruct: {
	header:               string      @go(Header)
	omit_if_not_present?: null | bool @go(OmitIfNotPresent,*bool)
}

// A MappingLabelSpecHeader is just the aggregate map of MappingLabelSpecHeaderStruct,
// above. The key in the map is the label key that it will set to that header value;
// there must be exactly one key in the map.
#MappingLabelSpecHeader: {[string]: #MappingLabelSpecHeaderStruct}

// A MappingLabelSpecGeneric is a longhand generic key: it states a string which
// will be included literally in the label.
#MappingLabelSpecGeneric: {
	generic_key: string @go(GenericKey)
	v3Key?:      string @go(V3Key)
}

// +kubebuilder:validation:Type="d6e-union:string,object"
#AddedHeader: _

#AddedHeaderFull: {
	value?:  string      @go(Value)
	append?: null | bool @go(Append,*bool)
}

#KeepAlive: {
	probes?:    null | int @go(Probes,*int)
	idle_time?: null | int @go(IdleTime,*int)
	interval?:  null | int @go(Interval,*int)
}

#CORS: {
	origins?:         null | #OriginList  @go(Origins,*OriginList)
	methods?:         #StringOrStringList @go(Methods)
	headers?:         #StringOrStringList @go(Headers)
	credentials?:     null | bool         @go(Credentials,*bool)
	exposed_headers?: #StringOrStringList @go(ExposedHeaders)
	max_age?:         string              @go(MaxAge)
}

// OriginList is a list of origin strings, either as a `[]string` or as a comma-separated `string`.
//
// +kubebuilder:validation:Type="d6e-union:string,array"
#OriginList: _

#RetryPolicy: {
	// +kubebuilder:validation:Enum={"5xx","gateway-error","connect-failure","retriable-4xx","refused-stream","retriable-status-codes"}
	retry_on?:        string     @go(RetryOn)
	num_retries?:     null | int @go(NumRetries,*int)
	per_try_timeout?: string     @go(PerTryTimeout)
}

#LoadBalancer: {
	// +kubebuilder:validation:Enum={"round_robin","ring_hash","maglev","least_request"}
	// +kubebuilder:validation:Required
	policy?:    string                     @go(Policy)
	cookie?:    null | #LoadBalancerCookie @go(Cookie,*LoadBalancerCookie)
	header?:    string                     @go(Header)
	source_ip?: null | bool                @go(SourceIp,*bool)
}

#LoadBalancerCookie: {
	// +kubebuilder:validation:Required
	name?: string @go(Name)
	path?: string @go(Path)
	ttl?:  string @go(Ttl)
}

// MappingStatus defines the observed state of Mapping
#MappingStatus: {
	// +kubebuilder:validation:Enum={"","Inactive","Running"}
	state?:  string @go(State)
	reason?: string @go(Reason)
}

// Mapping is the Schema for the mappings API
//
// +kubebuilder:object:root=true
// +kubebuilder:storageversion
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Source Host",type=string,JSONPath=`.spec.host`
// +kubebuilder:printcolumn:name="Source Prefix",type=string,JSONPath=`.spec.prefix`
// +kubebuilder:printcolumn:name="Dest Service",type=string,JSONPath=`.spec.service`
// +kubebuilder:printcolumn:name="State",type=string,JSONPath=`.status.state`
// +kubebuilder:printcolumn:name="Reason",type=string,JSONPath=`.status.reason`
#Mapping: {
	TypeMeta:  metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta    @go(ObjectMeta)
	spec?:     #MappingSpec          @go(Spec)
	status?:   null | #MappingStatus @go(Status,*MappingStatus)
}

// MappingList contains a list of Mappings.
//
// +kubebuilder:object:root=true
#MappingList: {
	TypeMeta:  metav1.#TypeMeta
	metadata?: metav1.#ListMeta @go(ListMeta)
	items: [...#Mapping] @go(Items,[]Mapping)
}
